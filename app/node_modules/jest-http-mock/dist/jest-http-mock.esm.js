import { createServer } from 'http';

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

var Resolvable = function Resolvable() {
  var _this = this;

  this.settled = false;

  this.resolve = function (data) {
    if (_this._resolve) {
      _this.settled = true;

      _this._resolve(data);
    }
  };

  this.reject = function (error) {
    if (_this._reject) {
      _this.settled = true;

      _this._reject(error);
    }
  };

  this.promise = new Promise(function (resolve, reject) {
    _this._resolve = resolve;
    _this._reject = reject;
  });
};
function bodyReader(request) {
  var promise;
  return function () {
    if (!promise) {
      promise = new Promise(function (resolve, reject) {
        var body = [];
        var rejected = false;
        request.on('data', function (chunk) {
          body.push(chunk);
        });
        request.on('error', function (error) {
          rejected = true;
          reject(error);
        });
        request.on('end', function () {
          if (rejected) {
            return;
          }

          resolve(Buffer.concat(body));
        });
      });
    }

    return promise;
  };
}

function generatePort() {
  return Math.floor(4000 + Math.random() * 4000);
}

var MockHttpServerImpl = /*#__PURE__*/function () {
  function MockHttpServerImpl(_options) {
    this._options = _options;
    this._requestHandlers = [];
    this._activeResponses = [];
    this._running = false;
    this._connections = [];
  }

  var _proto = MockHttpServerImpl.prototype;

  _proto.clear = function clear() {
    this._requestHandlers = [];
    this._activeResponses = [];

    for (var _iterator = _createForOfIteratorHelperLoose(this._connections), _step; !(_step = _iterator()).done;) {
      var conn = _step.value;
      conn.unref();
      conn.destroy();
    }

    this._connections = [];
  };

  _proto.start = function start() {
    var _this = this;

    if (this._running) {
      var _this$_promiseStart$p, _this$_promiseStart;

      return (_this$_promiseStart$p = (_this$_promiseStart = this._promiseStart) == null ? void 0 : _this$_promiseStart.promise) != null ? _this$_promiseStart$p : Promise.reject('Unexpected state');
    }

    this._running = true;
    this._promiseStart = new Resolvable();
    this._server = createServer(function (request, response) {
      var _request$url, _request$headers$orig;

      var url = new URL((_request$url = request.url) != null ? _request$url : '', _this.host);

      var handlers = _this._requestHandlers.filter(function (h) {
        return h.path === url.pathname;
      }); // Всегда и сразу разрешаем CORS


      response.setHeader('access-control-allow-origin', (_request$headers$orig = request.headers.origin) != null ? _request$headers$orig : '*');

      for (var _iterator2 = _createForOfIteratorHelperLoose(handlers), _step2; !(_step2 = _iterator2()).done;) {
        var handler = _step2.value;
        handler.handler(request, response);
      }

      _this._activeResponses.push(response);
    });

    this._server.listen(this._options.port, function () {
      var _this$_promiseStart2;

      (_this$_promiseStart2 = _this._promiseStart) == null ? void 0 : _this$_promiseStart2.resolve(_this);
    });

    this._server.on('connection', function (conn) {
      _this._connections.push(conn);

      conn.on('close', function () {
        _this._connections = _this._connections.filter(function (c) {
          return c !== conn;
        });
      });
    });

    return this._promiseStart.promise;
  };

  _proto.stop = function stop() {
    var _this2 = this;

    this._running = false;
    return new Promise(function (resolve, reject) {
      var _this2$_server, _this2$_server2;

      _this2.clear();

      (_this2$_server = _this2._server) == null ? void 0 : _this2$_server.unref();
      (_this2$_server2 = _this2._server) == null ? void 0 : _this2$_server2.close(function (error) {
        _this2._server = undefined;

        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });
  };

  _proto.waitForRequest = function waitForRequest(path) {
    var _this3 = this;

    var resolvable = new Resolvable(); // Обработчик запроса выстреливает один раз

    var handler = function handler(request, response, error) {
      _this3._removeRequestHandler(handler);

      _this3._activeResponses = _this3._activeResponses.filter(function (r) {
        return r !== response;
      });

      if (error) {
        resolvable.reject(error);
        return;
      } // Читаем тело запроса


      var _body = bodyReader(request);

      resolvable.resolve({
        request: request,
        response: response,
        // Тут тело запроса парсится
        body: function body(encoding) {
          return _body().then(function (buffer) {
            if (encoding === undefined) {
              return buffer;
            } else {
              return buffer.toString(encoding);
            }
          });
        }
      });
    };

    var entry = {
      path: path,
      handler: handler,
      resolvable: resolvable
    };

    this._requestHandlers.push(entry); // Setting up rejection by timeout


    var timer = setTimeout(function () {
      _this3._removeRequestHandler(handler);

      resolvable.reject(new Error('Timed out'));
    }, this._options.timeout);
    entry.promise = resolvable.promise.then(function (result) {
      return [null, result];
    })["catch"](function (error) {
      return [error, null];
    }).then(function (_ref) {
      var error = _ref[0],
          result = _ref[1];
      clearTimeout(timer);

      if (error) {
        return Promise.reject(error);
      } else {
        return Promise.resolve(result);
      }
    });
    return entry.promise;
  };

  _proto.stopWaiting = function stopWaiting(requestPromise) {
    this._requestHandlers = this._requestHandlers.filter(function (handler) {
      if (handler.promise === requestPromise) {
        handler.resolvable.reject(new Error('Cancelled'));
        return false;
      }

      return true;
    });
  };

  _proto._removeRequestHandler = function _removeRequestHandler(handler) {
    this._requestHandlers = this._requestHandlers.filter(function (h) {
      return h.handler !== handler;
    });
  };

  _createClass(MockHttpServerImpl, [{
    key: "port",
    get: function get() {
      return this._options.port;
    }
  }, {
    key: "host",
    get: function get() {
      return "http://localhost:" + this.port;
    }
  }]);

  return MockHttpServerImpl;
}();

function mockHttpServer(options) {
  var _options$port, _options$timeout;

  if (options === void 0) {
    options = {};
  }

  return new MockHttpServerImpl(_extends({}, options, {
    port: (_options$port = options.port) != null ? _options$port : generatePort(),
    timeout: (_options$timeout = options.timeout) != null ? _options$timeout : 1000
  }));
}

function useMockHttpServer(options) {
  if (options === void 0) {
    options = {};
  }

  var server = mockHttpServer(options);
  beforeEach(function () {
    server.clear();
    return server.start();
  });
  afterEach(function () {
    return server.stop();
  });
  return server;
}

export { useMockHttpServer };
//# sourceMappingURL=jest-http-mock.esm.js.map

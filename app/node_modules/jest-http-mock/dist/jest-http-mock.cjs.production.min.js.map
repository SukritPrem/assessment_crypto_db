{"version":3,"file":"jest-http-mock.cjs.production.min.js","sources":["../src/utils.ts","../src/index.ts"],"sourcesContent":["import * as http from 'http';\n\nexport class Resolvable<T = any> {\n  public readonly promise: Promise<T>;\n  public settled = false;\n  private _resolve?: (data: T) => void;\n  private _reject?: (error: any) => void;\n\n  constructor() {\n    this.promise = new Promise<T>((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  public resolve = (data: T) => {\n    if (this._resolve) {\n      this.settled = true;\n      this._resolve(data);\n    }\n  };\n\n  public reject = (error?: any) => {\n    if (this._reject) {\n      this.settled = true;\n      this._reject(error);\n    }\n  };\n}\n\nexport function bodyReader(\n  request: http.IncomingMessage\n): () => Promise<Buffer> {\n  let promise: Promise<Buffer>;\n\n  return () => {\n    if (!promise) {\n      promise = new Promise<Buffer>((resolve, reject) => {\n        const body: Buffer[] = [];\n        let rejected = false;\n\n        request.on('data', chunk => {\n          body.push(chunk);\n        });\n\n        request.on('error', error => {\n          rejected = true;\n          reject(error);\n        });\n\n        request.on('end', () => {\n          if (rejected) {\n            return;\n          }\n\n          resolve(Buffer.concat(body));\n        });\n      });\n    }\n\n    return promise;\n  };\n}\n","import * as http from 'http';\nimport { Socket } from 'net';\n\nimport { bodyReader, Resolvable } from './utils';\n\nexport interface MockHttpServerOptions {\n  port: number;\n  timeout: number;\n}\n\nexport interface MockHttpServer {\n  readonly port: number;\n  readonly host: string;\n  waitForRequest(path: string): Promise<RequestMapEntry>;\n  stopWaiting(requestPromise: Promise<RequestMapEntry>): void;\n}\n\nfunction generatePort(): number {\n  return Math.floor(4000 + Math.random() * 4000);\n}\n\nexport type RequestHandler = (\n  request: http.IncomingMessage,\n  response: http.ServerResponse,\n  error?: Error\n) => void;\n\ninterface RequestMapEntry {\n  request: http.IncomingMessage;\n  response: http.ServerResponse;\n  body(encoding: BufferEncoding): Promise<string>;\n  body(): Promise<Buffer>;\n}\n\ninterface RequestHandlerEntry {\n  path: string;\n  handler: RequestHandler;\n  resolvable: Resolvable<RequestMapEntry>;\n  promise?: Promise<RequestMapEntry>;\n}\n\nclass MockHttpServerImpl implements MockHttpServer {\n  private _server?: http.Server;\n  private _promiseStart?: Resolvable<this>;\n  private _requestHandlers: RequestHandlerEntry[] = [];\n  private _activeResponses: http.ServerResponse[] = [];\n  private _running = false;\n  private _connections: Socket[] = [];\n\n  constructor(private readonly _options: MockHttpServerOptions) {}\n\n  get port(): number {\n    return this._options.port;\n  }\n\n  get host(): string {\n    return `http://localhost:${this.port}`;\n  }\n\n  clear() {\n    this._requestHandlers = [];\n    this._activeResponses = [];\n\n    for (const conn of this._connections) {\n      conn.unref();\n      conn.destroy();\n    }\n\n    this._connections = [];\n  }\n\n  start(): Promise<this> {\n    if (this._running) {\n      return this._promiseStart?.promise ?? Promise.reject('Unexpected state');\n    }\n\n    this._running = true;\n    this._promiseStart = new Resolvable<this>();\n\n    this._server = http.createServer((request, response) => {\n      const url = new URL(request.url ?? '', this.host);\n      const handlers = this._requestHandlers.filter(\n        h => h.path === url.pathname\n      );\n\n      // Всегда и сразу разрешаем CORS\n      response.setHeader(\n        'access-control-allow-origin',\n        request.headers.origin ?? '*'\n      );\n\n      for (const handler of handlers) {\n        handler.handler(request, response);\n      }\n\n      this._activeResponses.push(response);\n    });\n\n    this._server.listen(this._options.port, () => {\n      this._promiseStart?.resolve(this);\n    });\n\n    this._server.on('connection', conn => {\n      this._connections.push(conn);\n\n      conn.on('close', () => {\n        this._connections = this._connections.filter(c => c !== conn);\n      });\n    });\n\n    return this._promiseStart.promise;\n  }\n\n  stop(): Promise<void> {\n    this._running = false;\n\n    return new Promise((resolve, reject) => {\n      this.clear();\n      this._server?.unref();\n\n      this._server?.close((error?) => {\n        this._server = undefined;\n\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  waitForRequest(path: string): Promise<RequestMapEntry> {\n    const resolvable = new Resolvable<RequestMapEntry>();\n\n    // Обработчик запроса выстреливает один раз\n    const handler: RequestHandler = (request, response, error) => {\n      this._removeRequestHandler(handler);\n      this._activeResponses = this._activeResponses.filter(r => r !== response);\n\n      if (error) {\n        resolvable.reject(error);\n        return;\n      }\n\n      // Читаем тело запроса\n      const body = bodyReader(request);\n\n      resolvable.resolve({\n        request,\n        response,\n\n        // Тут тело запроса парсится\n        body(encoding?: BufferEncoding): Promise<any> {\n          return body().then(buffer => {\n            if (encoding === undefined) {\n              return buffer;\n            } else {\n              return buffer.toString(encoding);\n            }\n          });\n        },\n      });\n    };\n\n    const entry: RequestHandlerEntry = { path, handler, resolvable };\n    this._requestHandlers.push(entry);\n\n    // Setting up rejection by timeout\n    const timer = setTimeout(() => {\n      this._removeRequestHandler(handler);\n      resolvable.reject(new Error('Timed out'));\n    }, this._options.timeout);\n\n    entry.promise = resolvable.promise\n      .then(result => [null, result])\n      .catch(error => [error, null])\n      .then(([error, result]) => {\n        clearTimeout(timer);\n\n        if (error) {\n          return Promise.reject(error);\n        } else {\n          return Promise.resolve(result);\n        }\n      });\n\n    return entry.promise;\n  }\n\n  stopWaiting(requestPromise: Promise<RequestMapEntry>): void {\n    this._requestHandlers = this._requestHandlers.filter(handler => {\n      if (handler.promise === requestPromise) {\n        handler.resolvable.reject(new Error('Cancelled'));\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  private _removeRequestHandler(handler: RequestHandler) {\n    this._requestHandlers = this._requestHandlers.filter(\n      h => h.handler !== handler\n    );\n  }\n}\n\nfunction mockHttpServer(\n  options: Partial<MockHttpServerOptions> = {}\n): MockHttpServerImpl {\n  return new MockHttpServerImpl({\n    ...options,\n    port: options.port ?? generatePort(),\n    timeout: options.timeout ?? 1000,\n  });\n}\n\nexport function useMockHttpServer(\n  options: Partial<MockHttpServerOptions> = {}\n): MockHttpServer {\n  const server = mockHttpServer(options);\n\n  beforeEach(() => {\n    server.clear();\n    return server.start();\n  });\n\n  afterEach(() => {\n    return server.stop();\n  });\n\n  return server;\n}\n"],"names":["Resolvable","data","_this","_resolve","settled","error","_reject","promise","Promise","resolve","reject","MockHttpServerImpl","_options","clear","_requestHandlers","_activeResponses","this","_connections","conn","unref","destroy","start","_running","_promiseStart","_this$_promiseStart","_server","http","request","response","url","URL","host","handlers","filter","h","path","pathname","setHeader","headers","origin","handler","push","listen","port","on","c","stop","_this2","close","undefined","waitForRequest","resolvable","_this3","_removeRequestHandler","r","body","rejected","chunk","Buffer","concat","bodyReader","encoding","then","buffer","toString","entry","timer","setTimeout","Error","timeout","result","clearTimeout","stopWaiting","requestPromise","options","server","Math","floor","random","mockHttpServer","beforeEach","afterEach"],"mappings":"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"}